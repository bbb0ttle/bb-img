class BBImg extends HTMLElement{static get observedAttributes(){return["src","alt","placeholder","max-width","root-margin","aspect-ratio"]}constructor(){super(),this.observer=null,this.resizeObserver=null,this.img=null,this.isLoaded=!1,this.loadId=0,this.aspectRatio=1.5,this.attachShadow({mode:"open"})}get container(){return this.shadowRoot?.querySelector(".container")??null}connectedCallback(){this.parseAspectRatio(),this.render(),this.setupLazyLoading(),this.setupResizeObserver()}disconnectedCallback(){this.cleanup()}cleanup(){this.observer&&(this.observer.disconnect(),this.observer=null),this.resizeObserver&&(this.resizeObserver.disconnect(),this.resizeObserver=null),this.img&&(this.img.onload=null,this.img.onerror=null)}parseAspectRatio(){const t=this.getAttribute("aspect-ratio");if(t){const[e,i]=t.split("/").map(Number);e&&i&&(this.aspectRatio=e/i)}}normalizeMaxWidth(t){return t?/^\d+(\.\d+)?$/.test(t.trim())?`${t}px`:t:"100%"}calculateMinHeight(t){return t/this.aspectRatio+"px"}updateMinHeight(){const t=this.container;if(!t||this.isLoaded)return;const e=t.getBoundingClientRect().width;if(e>0){const i=this.calculateMinHeight(e);t.style.minHeight=i}}setupResizeObserver(){if(!("ResizeObserver"in window))return void this.updateMinHeight();const t=this.container;t&&(this.resizeObserver=new ResizeObserver(e=>{for(const i of e)if(i.contentRect){const e=i.contentRect.width;if(e>0&&!this.isLoaded){const i=this.calculateMinHeight(e);t.style.minHeight=i}}}),this.resizeObserver.observe(t))}attributeChangedCallback(t,e,i){if(e!==i)switch(t){case"src":this.isConnected&&this.resetAndLoad();break;case"alt":this.img&&(this.img.alt=i||"");break;case"placeholder":this.updatePlaceholderColor(i);break;case"max-width":this.updateMaxWidth(i),requestAnimationFrame(()=>this.updateMinHeight());break;case"aspect-ratio":this.parseAspectRatio(),this.updateAspectRatio()}}updatePlaceholderColor(t){const e=this.container;e&&!this.isLoaded&&(e.style.backgroundColor=t||"#f5f5f5")}updateMaxWidth(t){const e=this.normalizeMaxWidth(t);this.style.maxWidth=e;const i=this.container;i&&(i.style.maxWidth=e)}updateAspectRatio(){const t=this.container;t&&(t.style.aspectRatio=`${this.aspectRatio}`,this.updateMinHeight())}resetAndLoad(){this.isLoaded=!1,this.loadId++,this.img&&(this.img.classList.remove("loaded"),this.img.onload=null,this.img.onerror=null,this.img.removeAttribute("src"));const t=this.container;t&&(t.classList.remove("loaded"),t.style.backgroundColor=this.getAttribute("placeholder")||"#f5f5f5",t.style.minHeight=""),this.observer&&this.observer.disconnect(),this.setupLazyLoading()}render(){const t=this.getAttribute("alt")||"",e=this.getAttribute("placeholder")||"#f5f5f5",i=this.getAttribute("max-width"),n=this.normalizeMaxWidth(i);this.style.maxWidth=n,this.style.display="block",this.shadowRoot.innerHTML=`\n      <style>\n        :host {\n          display: block;\n          position: relative;\n          width: 100%;\n          max-width: ${n};\n          margin: 0 auto;\n        }\n        \n        .container {\n          position: relative;\n          width: 100%;\n          max-width: ${n};\n          aspect-ratio: ${this.aspectRatio};\n          /* min-height 由 JS 根据实际宽度动态计算 */\n          background-color: ${e};\n          overflow: hidden;\n          margin: 0 auto;\n          transition: background-color 0.8s cubic-bezier(0.4, 0, 0.2, 1);\n        }\n        \n        /* 极简骨架屏：极淡的呼吸感 */\n        .container:not(.loaded)::before {\n          content: '';\n          position: absolute;\n          top: 0;\n          left: 0;\n          right: 0;\n          bottom: 0;\n          background: linear-gradient(\n            90deg,\n            transparent 0%,\n            rgba(128, 128, 128, 0.03) 50%,\n            transparent 100%\n          );\n          transform: translateX(-100%);\n          animation: breathe 3s ease-in-out infinite;\n        }\n        \n        @keyframes breathe {\n          0%, 100% { \n            transform: translateX(-100%);\n            opacity: 0;\n          }\n          50% { \n            transform: translateX(100%);\n            opacity: 1;\n          }\n        }\n        \n        .container.loaded {\n          background-color: transparent;\n        }\n        \n        .container.loaded::before {\n          animation: none;\n          opacity: 0;\n          transition: opacity 0.6s ease;\n        }\n        \n        img {\n          width: 100%;\n          height: 100%;\n          object-fit: cover;\n          opacity: 0;\n          transition: opacity 1.2s cubic-bezier(0.4, 0, 0.2, 1),\n                      transform 1.2s cubic-bezier(0.4, 0, 0.2, 1);\n          transform: scale(1.02);\n          will-change: opacity, transform;\n          decoding: async;\n        }\n        \n        img.loaded {\n          opacity: 1;\n          transform: scale(1);\n        }\n        \n        /* 极简错误状态 */\n        .error {\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          width: 100%;\n          height: 100%;\n          color: #ccc;\n          font-size: 13px;\n          letter-spacing: 0.05em;\n        }\n        \n        .error-icon {\n          width: 32px;\n          height: 32px;\n          opacity: 0.3;\n        }\n      </style>\n      <div class="container">\n        <img alt="${t}" />\n      </div>\n    `,this.img=this.shadowRoot.querySelector("img")}setupLazyLoading(){if(!("IntersectionObserver"in window)||this.isInViewport())return void this.loadImage();const t=this.getAttribute("root-margin")||"50px";this.observer=new IntersectionObserver(t=>{t.forEach(t=>{t.isIntersecting&&!this.isLoaded&&(this.loadImage(),this.observer?.disconnect(),this.observer=null)})},{rootMargin:t,threshold:.01}),this.observer.observe(this)}isInViewport(){const t=this.getBoundingClientRect();return t.top<window.innerHeight&&t.bottom>0}loadImage(){const t=this.getAttribute("src");if(!t||!this.img)return;const e=++this.loadId;this.isLoaded=!0,this.img.onload=async()=>{if(e===this.loadId){try{"decode"in this.img&&await this.img.decode()}catch{}this.img.classList.add("loaded"),this.container?.classList.add("loaded")}},this.img.onerror=()=>{e===this.loadId&&(console.error(`Failed to load image: ${t}`),this.showError())},this.img.src=t}showError(){const t=this.container;t&&(t.innerHTML='\n      <div class="error">\n        <svg class="error-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">\n          <path stroke-linecap="round" stroke-linejoin="round" \n            d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />\n        </svg>\n      </div>\n    ',t.classList.add("loaded"))}reload(){this.resetAndLoad()}get loaded(){return this.isLoaded}}customElements.define("bb-img",BBImg);export{BBImg};