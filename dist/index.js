class BBImg extends HTMLElement{static get observedAttributes(){return["src","alt","placeholder","max-width","root-margin"]}constructor(){super(),this.observer=null,this.img=null,this.isLoaded=!1,this.loadId=0,this.attachShadow({mode:"open"})}get container(){return this.shadowRoot?.querySelector(".container")??null}connectedCallback(){this.render(),this.setupLazyLoading()}disconnectedCallback(){this.cleanup()}cleanup(){this.observer&&(this.observer.disconnect(),this.observer=null),this.img&&(this.img.onload=null,this.img.onerror=null)}attributeChangedCallback(t,e,n){if(e!==n)switch(t){case"src":this.isConnected&&this.resetAndLoad();break;case"alt":this.img&&(this.img.alt=n||"");break;case"placeholder":this.updatePlaceholderColor(n);break;case"max-width":this.updateMaxWidth(n)}}updatePlaceholderColor(t){const e=this.container;e&&!this.isLoaded&&(e.style.backgroundColor=t||"#dfdfdf")}updateMaxWidth(t){const e=t||"100%";this.style.maxWidth=e;const n=this.container;n&&(n.style.maxWidth=e)}resetAndLoad(){this.isLoaded=!1,this.loadId++,this.img&&(this.img.classList.remove("loaded"),this.img.onload=null,this.img.onerror=null,this.img.removeAttribute("src")),this.container?.classList.remove("loaded"),this.observer&&this.observer.disconnect(),this.setupLazyLoading()}render(){const t=this.getAttribute("alt")||"",e=this.getAttribute("placeholder")||"#dfdfdf",n=this.getAttribute("max-width")||"100%";this.getAttribute("root-margin");this.style.maxWidth=n,this.style.display="block",this.shadowRoot.innerHTML=`\n      <style>\n        :host {\n          display: block;\n          position: relative;\n          width: 100%;\n          max-width: ${n};\n          margin: 0 auto; /* 居中显示 */\n        }\n        .container {\n          position: relative;\n          width: 100%;\n          max-width: ${n};\n          aspect-ratio: 3/2;\n          background-color: ${e};\n          overflow: hidden;\n          margin: 0 auto;\n        }\n        /* 骨架屏脉冲动画 */\n        .container:not(.loaded)::after {\n          content: '';\n          position: absolute;\n          top: 0;\n          left: 0;\n          right: 0;\n          bottom: 0;\n          background: linear-gradient(\n            90deg,\n            transparent 0%,\n            rgba(255, 255, 255, 0.4) 50%,\n            transparent 100%\n          );\n          transform: translateX(-100%);\n          animation: shimmer 1.5s infinite;\n        }\n        @keyframes shimmer {\n          100% { transform: translateX(100%); }\n        }\n        .container.loaded {\n          background-color: transparent;\n        }\n        .container.loaded::after {\n          display: none;\n        }\n        img {\n          width: 100%;\n          height: 100%;\n          object-fit: cover;\n          opacity: 0;\n          transition: opacity 0.3s ease-in-out;\n          decoding: async;\n        }\n        img.loaded {\n          opacity: 1;\n        }\n        .error {\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          width: 100%;\n          height: 100%;\n          color: #999;\n          font-size: 14px;\n        }\n        .error-icon {\n          width: 48px;\n          height: 48px;\n          opacity: 0.5;\n        }\n      </style>\n      <div class="container">\n        <img alt="${t}" />\n      </div>\n    `,this.img=this.shadowRoot.querySelector("img")}setupLazyLoading(){if(!("IntersectionObserver"in window)||this.isInViewport())return void this.loadImage();const t=this.getAttribute("root-margin")||"50px";this.observer=new IntersectionObserver(t=>{t.forEach(t=>{t.isIntersecting&&!this.isLoaded&&(this.loadImage(),this.observer?.disconnect(),this.observer=null)})},{rootMargin:t,threshold:.01}),this.observer.observe(this)}isInViewport(){const t=this.getBoundingClientRect();return t.top<window.innerHeight&&t.bottom>0}loadImage(){const t=this.getAttribute("src");if(!t||!this.img)return;const e=++this.loadId;this.isLoaded=!0,this.img.onload=async()=>{if(e===this.loadId){try{"decode"in this.img&&await this.img.decode()}catch{}this.img.classList.add("loaded"),this.container?.classList.add("loaded")}},this.img.onerror=()=>{e===this.loadId&&(console.error(`Failed to load image: ${t}`),this.showError())},this.img.src=t}showError(){const t=this.container;t&&(t.innerHTML='\n      <div class="error">\n        <svg class="error-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">\n          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" \n            d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />\n        </svg>\n      </div>\n    ',t.classList.add("loaded"))}reload(){this.resetAndLoad()}get loaded(){return this.isLoaded}}customElements.define("bb-img",BBImg);export{BBImg};